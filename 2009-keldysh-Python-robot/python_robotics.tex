\documentclass{beamer}

\mode<presentation>
{
	\usetheme{Frankfurt}
	\setbeamercovered{transparent}
}

\usepackage[russian]{babel}
\usepackage[utf8]{inputenc}
\usepackage{listings,bera}
\lstset{language=Python, numberstyle=\tiny, keywordstyle=\color{blue},numbers=left,commentstyle=\color{green},
basicstyle=\footnotesize}

\usepackage{mathptmx}
\usepackage{graphics}
\usepackage[scaled=.90]{helvet}
\usepackage{courier}

\usepackage[T1]{fontenc}

\title{Использование языка Python в задачах робототехники}
\author{Кирсанов К.Б.}
\institute[sensorika]
{ИПМ им. Келдыша РАН, Международная лаборатория ``Сенсорика``}
\date{05.10.09 / Школа молодых учёных Graphicon`2009 }

\beamerdefaultoverlayspecification{<+->}

\begin{document}

\begin{frame}
\titlepage
\end{frame}

\section{Введение}
\subsection{Язык Python}
\begin{frame}
\frametitle{Введение}
\framesubtitle{Python — высокоуровневый интерпретируемый динамичский язык общего назначения.}
\begin{itemize}
  \item<1> \alert{Основные особенности}: минималистский синтаксис, динамическая типизация, автоматическое управление памятью, 
интроспекция, элементы функционального программирования, высокоуровневые структуры данных  \item
  \item<1> \alert{Автор} языка, голландец Гвидо ван Россум (Guido van Rossum), создал его как адаптацию учебного языка ABC для
  нужд unix/C программистов    
\end{itemize}
\end{frame}

\subsection{Дао языка}
\begin{frame}
\frametitle{Введение}
\framesubtitle{Результат исполения ``import this``}
\begin{itemize}
    \item<1> Красивое лучше уродливого.
     \item<1> Явное лучше неявного.
     \item<1> Простое лучше сложного.
     \item<1> Сложное лучше усложнённого.
     \item<1> Единое лучше сцепленного.
     \item<1> Рассеянное лучше плотного.
     \item<1> Чёткость важна.
     \item<1> Частные случаи не настолько существенны, чтобы нарушать правила.
     \item<1> Хотя практичность важнее чистоты.
     \item<1> Ошибки никогда не должны умалчиваться.
     \item<1> Кроме тех случаев, когда они явны.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Введение}
\framesubtitle{Результат исполения ``import this``. Продожение.}
\begin{itemize}
     \item<1-> Если что-то не ясно, сопротивляйтесь искушению угадать.
	 \item<1-> Должен существовать один — и, желательно, только один — очевидный способ сделать это.
	 \item<1-> Хотя поначалу он может быть не очевиден, если только ты не голландец.
	 \item<1-> Сейчас лучше, чем никогда.
	 \item<1-> Хотя никогда часто бывает лучше, чем прямо сейчас.
	 \item<1-> Если реализацию сложно объяснить — это плохая идея.
	 \item<1-> Если реализацию легко объяснить — это может быть хорошей идеей.
	 \item<1-> Пространства имён — великолепная идея. Давайте придумаем больше таких! 
\end{itemize}
\end{frame}

\subsection{Влияние других языков}
\begin{frame}
\frametitle{Введение}
\framesubtitle{Влияние других языков}
Python не содержит ни одной новой идеи, но является удачной комбинацией уже существующих:
\begin{itemize}
  \item<1> \textbf{ABC} - отступы для группировки операторов 
  \item<1> \textbf{Haskell} - операции над списками
  \item<1> \textbf{Modula-3} - пакеты, модули, именованные аргументы функций
  \item<1> \textbf{Smalltalk} - объектно-ориентированное программирование 
  \item<1> \textbf{Lisp} – элементы функционального программирования.
  \item<1> \textbf{Java} – часть стандартной библиотеки
\end{itemize}
\end{frame}

\subsection{Реализации языка}
\begin{frame}
\frametitle{Введение}
\framesubtitle{Реализации языка}
Язык не стандартизируется ISO. В качестве стандарта выступает реализация CPython.

\begin{itemize}
  \item<1> Интерпретатор:
  	  \begin{itemize}
	    \item<1> \alert{CPython – стандартная реализация (X86, ARM, MIPS)}
	    \item<1> TinyPy -  минималистский реализация ( 64K )
	    \item<1> Python for S60 - Symian(Nokia)  
	  \end{itemize}
  \item<1> Компилятор в байткод виртуальных машин  
	\begin{itemize}
	    \item<1> Jython – Java
	    \item<1> Iron Python – Microsoft .NET
	    \item<1> Unladen Swallow – LLVM (Low Level Virtual Machine) 
    \end{itemize}

  \item<1> Другие реализации:
     \begin{itemize}
	    \item<1> PyPy – Интерпретатор Python, написанный на Python
     \end{itemize}    
\end{itemize}

\end{frame}

\section{Язык}

\subsection{Пример простейшей программы}
\begin{frame}
\frametitle{Язык Python}
\framesubtitle{Пример простейшей программы. Отсупы как операторные скобки}
\lstinputlisting{simple_program.py}
\end{frame}

\subsection{Модули}
\begin{frame}
\frametitle{Язык Python}
\framesubtitle{Модули}
Модули Python должны находится в текущем каталоги или в одной из системных каталогов из sys.path. Модули могут быть упакованы в
ZIP.

Подключение модуля осуществляется п мощью команты import
\lstinputlisting{import.py}
При импортировании модули кешируются и их повторное импортировние игнорируется
\end{frame}

\subsection{Типы данных}
\begin{frame}
\frametitle{Язык Python}
\framesubtitle{Типы данных}
\lstinputlisting{datatypes.py}
\end{frame}


\subsubsection{Списки}
\begin{frame}
\frametitle{Язык Python}
\framesubtitle{Типы данных - Списки}
\lstinputlisting{lists.py}
\end{frame}

\begin{frame}
\frametitle{Язык Python}
\framesubtitle{Операции над списками: срезы}
Пусть дан список  A=[1,2,3,4,5,6,7,8,9]
\begin{itemize}
	\item<1> A или A[:] - все элементы
	\item<1> A[0] – первый элемент
	\item<1> A[-1] – последний элемент
	\item<1> A[0:3] – c первого по третий
	\item<1> A[:-2] – все элементы, кроме двух последних
	\item<1> A[2:] – все элементы, кроме двух первых
	\item<1> A[0:8:2] – элементы с 1-го по 8-й с шагом 2
\end{itemize}

Дополнительные операции
\begin{itemize}
	\item<1> len(A), max(A), min(A), sum(A), sort(A)
	\item<1> распаковка - a,b = [1,2]
\end{itemize} 
\end{frame}

\begin{frame}
\frametitle{Язык Python}
\framesubtitle{Операции над списками. Пример: Контроль длинны истории измерений датчика}
\lstinputlisting{sample_measure.py}
\end{frame}

\begin{frame}
\frametitle{Язык Python}
\framesubtitle{Списковые операции}
\lstinputlisting{sample_list.py}
\end{frame}

\subsubsection{Словари}
\begin{frame}
\frametitle{Язык Python}
\framesubtitle{Типы данных - Словари}
Словарь (ассоциативный массив) - осуществляет к элементу произвольного типа по ключу произвольного типа.
\lstinputlisting{sample_dict.py}
\end{frame}

\subsubsection{Кортежи и строки}
\begin{frame}
\frametitle{Язык Python}
\framesubtitle{Типы данных - Котрежи и строки}
Кортеж (tuple) - \alert{неизменяемая}(immutable) последовательность объектов.
\lstinputlisting{sample_tuple.py}
\end{frame}

\subsection{Циклы}
\begin{frame}
\frametitle{Язык Python}
\framesubtitle{Организация циклов}
В языке Python приняты циклы, перебирающие элементы:
\lstinputlisting{sample_for.py}
\end{frame}

\subsection{Функции}
\begin{frame}
\frametitle{Язык Python}
\framesubtitle{Функции и их аргументы}
Значения передаются ``по ссылке``. Возможно использование именованных аргументов.
\lstinputlisting{sample_func.py}
Из за принятной типизации невозможно создать перегруженные функции
\end{frame}

\begin{frame}
\frametitle{Язык Python}
\framesubtitle{Функции и их аргументы. Списковые аргументы}
\lstinputlisting{sample_func2.py}
\end{frame}

\subsubsection{Замыкания}
\begin{frame}
\frametitle{Язык Python}
\framesubtitle{Замыкания - функции, ссылающиеся на свободные переменные в своём лексическом контексте}
Пример: Добавление временных меток к сенсорным данным
\lstinputlisting{close.py}
\end{frame}

\subsubsection{Замыкания}
\begin{frame}
\frametitle{Язык Python}
\framesubtitle{Продолжения(generators, continuation) - представляет состояние программы в определённый момент, которое может быть
сохранено и использовано для перехода в это состояние}
\lstinputlisting{generators.py}
\end{frame}


\subsubsection{Функции высших порядков}
\begin{frame}
\frametitle{Язык Python}
\framesubtitle{Функции высших порядков - функции принимающие в ачестве аргументов другиме функции}
\lstinputlisting{map.py}
\end{frame}

\subsection{Классы}
\begin{frame}
\frametitle{Язык Python}
\framesubtitle{Классы}
\lstinputlisting{class.py}
\end{frame}


\section{Проблемы}
\subsection{Низкая производительность}
\begin{frame}
\frametitle{Проблемы}
\framesubtitle{Низкая производительность}
Интерпретатор Python, хотя и является одним из самых быстрых (в 2-3 раза быстрее tk) но, тем не мение, заметно отстает от С (до
1000 раз на некоторых тестах)
\\
Пути решения:
\begin{itemize}
	\item<1> psyco - ускорение в 2-100 раз
	\item<1> Выявить вычислительно-сложные функции и переписать их на С
	\item<1> Воспользоваться математическими библиотеками для Python
	\item<1> Реализовывать на Python лишь общую логику программы, а все частности решать в других языках
\end{itemize}
\end{frame}

\subsubsection{Psyco}
\begin{frame}
\frametitle{Проблемы:Низкая производительность}
\framesubtitle{Решение: psyco}
http://psyco.sourceforge.net/
\\
Осуществляет частичную специализацию программы.
\begin{itemize}
	\item<1> Существенный расход памяти.
	\item<1> Автор покинул проект и перешел в PyPy
	\item<1> Дает стократное ускорение лишь на специально подготовленных тестах.
\end{itemize}
\end{frame}
\begin{frame}
\frametitle{Проблемы:Низкая производительность}
\framesubtitle{psyco: пример использования}
\lstinputlisting{psyco_test.py}
\end{frame}

\subsection{Невозможность организации параллельных вычичлений в CPython}
\begin{frame}
\frametitle{Проблемы}
\framesubtitle{Невозможность организации параллельных вычичлений в CPython}
\alert{Глобальная блокировка интерпретатора (GIL)} - CPython не потокобезопасен. Все потоки реализуются через коллективную
многозадачность. Переключение задач раз в 100 инструкций
Это не является проблемой т.к.: 
\begin{itemize}
	\item<1> Можно использовать MPI
	\item<1> На бортовой ЭВМ всё равно 1 энергоэффективный прцессор и истинная многопоточность не нужна
	\item<1> GIL на распространяется на написанные на С фрагменты, т.е. на операции ввода-вывода, функции библиотек и т.п. 
\end{itemize}
Это удобно:
\begin{itemize}
	\item<1> Не нужно думать о примитивах синхронизации
	\item<1> Упрощается отладка
	\item<1> Экономия памяти
\end{itemize}
WEB сервер Tornado, облcуживающий Fаcebook, написан на Python и облуживает ~8000 одновременных подключений.
\end{frame}

\subsection{Склонность к ошибкам}
\begin{frame}
\frametitle{Проблемы}
\framesubtitle{Склонность к ошибкам - Динамическая типизация лишает программиста контроля типов со стороны компилятора}

Пути решения:
\begin{itemize}
	\item<1> Использовать PyChecker или pylint (анализаторы исходного кода, обнаруживают большинство ошибок)
	\item<1> Регулярное регрессионное тестирование
	\item<1> Реализовывать на Python лишь общую логику программы, а все частности решать в других языках
\end{itemize}
\end{frame}


\section{Бибилиотеки}
\begin{frame}
\frametitle{Библиотеки}
\framesubtitle{В репозитарии Lunux Ubutu более 1400 Python программ и библиотек}
Pyhon чрезвычайно просто интегрируется с существующими программами на С. В результате для него существует огромное количество
сторонних библиотек:
\begin{itemize}
    \item<1> psyco - специализирующий компилятор 
	\item<1> numpy - быстрые вычисления а массивах
	\item<1> mathplotlib - графопостроитель
	\item<1> scipy - научные расчеты (включает numpy) 
	\item<1> rpyc - распределенные вычиcления
	\item<1> pygame - создание комп.игр (джойстик, клавиатура, мышь, 2D и звуковые библиотеки)
	\item<1> pyserial - взаимодействие по RS-232
	\item<1> pyCUDA
	\item<1> OpenCV
	\item<1> OpenGl, BluetTooth, \ldots 
\end{itemize}

\end{frame}

\section{Интеграция}
\begin{frame}
\frametitle{Интеграция}
\framesubtitle{Встраивание и расширение}
Python предлагает 2 способа интеграции с уже существующим ПО:
\begin{itemize}
    \item<1> Встраивание(embedding): интерпретатор Python встраивается в целевое ПО 
	\item<1> Раcширение(extending): целевое ПО реализуется как библиотека для Python 
\end{itemize}
Т.к. CPython реализован на С, то обе эти операции выполняются довольно легко.
Суеществует ряд библиотек и программ, ещё больше упрощающих этот процесс: Boost::Python, Swing, Blitz, Pyrex, f2py, Weave
\end{frame}

\subsection{Встраивание}
\begin{frame}
\frametitle{Интеграция}
\framesubtitle{Встраивание c использовнием boost::python}
\lstset{language=C}
\lstinputlisting{boost.c}
\lstset{language=Python}
\end{frame}

\subsection{Расширение}
\begin{frame}
\frametitle{Интеграция}
\framesubtitle{Расширение c использовнием scipy.wave}
Компилирует С++ вставки в Python коде ``на лету``, автоматически сосздавя подключаемые модули и повторно используя их при
необходимости:
\lstinputlisting{wave.py}
\end{frame}

\end{document}